# 개요

우리는 종종 Composable Architecture(줄여서 TCA)에 관한 온라인 기사나 논의들이 오래되었거나 약간 잘못된 정보를 담고 있는 것을 봅니다. 이러한 글들은 주로 TCA의 최신 버전에서 여전히 존재하는 "단점"들이 어떤 "장점"을 제공하는지 설명하지 않은 채, "단점"에만 집중하는 경향이 있습니다.

하지만 "단점"에만 집중하는 것은 전체적인 맥락을 놓치는 것입니다. 비유하자면, Swift의 값 타입(value types)에 대해 클래스처럼 안정적인 식별성이 없다는 "단점"을 신랄하게 비판하는 글을 쓸 수도 있겠지만, 이는 값 타입의 가장 큰 장점인 가벼운 복사와 비교 기능을 놓치는 것과 같습니다!

앱 아키텍처는 trade-off로 가득 차 있으며, 각각의 선택에서 얻는 것과 잃는 것에 대해 깊이 생각하는 것이 중요합니다. 우리는 몇 가지 흔한 오해들을 해소하기 위해 다음과 같은 이슈들을 모아보았습니다:

## 자주 제기되는 질문들

1. TCA는 모든 종류의 앱에 사용되어야 하나요?
2. 제 앱의 아키텍처로 서드파티 라이브러리를 채택해야 하나요?
3. TCA는 SwiftUI의 방향성에 반하나요?
4. TCA는 단순히 Redux의 포팅이 아닌가요? 라이브러리가 필요한가요?
5. TCA로 만든 기능들은 보일러플레이트가 많은가요?
6. 별도의 "액션" enum을 유지하는 것이 불필요한 작업 아닌가요?
7. 앱의 모든 상태가 하나의 거대한 타입에 보관되어 TCA 기능이 비효율적인가요?
8. 그것이 뷰의 과도한 렌더링을 유발하나요?
9. 큰 값 타입은 변경하기에 비용이 많이 드나요?
10. 큰 값 타입이 스택 오버플로우를 일으킬 수 있나요?
11. TCA 기능들은 과도한 "핑퐁"이 있지 않나요?
12. 기능들이 값 타입으로 만들어진다면, 값 타입은 복사되므로 상태를 공유할 수 없지 않나요?
13. TCA를 배우거나 사용하기 위해 Point-Free 구독이 필요한가요?
14. TCA를 사용하기 위해 "함수형 프로그래밍"에 익숙해야 하나요?

## 주요 질문에 대한 답변

### TCA는 모든 종류의 앱에 사용되어야 하나요?

Swift나 SwiftUI를 처음 배우는 사람들에게는 TCA를 권장하지 않습니다. TCA는 SwiftUI를 대체하는 것이 아니라 SwiftUI와 함께 사용되도록 설계되었습니다. TCA를 제대로 활용하기 위해서는 SwiftUI의 모든 기본 개념들에 익숙해야 합니다.

또한 네트워크에서 JSON을 로드하고 표시하는 것이 주된 기능인 단순한 "리더" 앱의 경우에는 TCA가 그다지 빛을 발하지 않습니다. 이러한 앱들은 복잡한 로직이나 부수 효과가 많지 않기 때문에 TCA의 이점이 명확하지 않습니다.

일반적으로 기본 SwiftUI(간결한 도메인 모델링에 집중)로 프로젝트를 시작하고, 나중에 TCA의 기능이 필요할 때 전환하는 것이 좋습니다.

### 앱 아키텍처로 서드파티 라이브러리를 채택해야 하나요?

서드파티 라이브러리 채택은 팀과 함께 신중한 논의와 고려 후에 내려야 할 중요한 결정입니다. 우리가 대신 결정할 수는 없습니다. 🙂

하지만 "직접 만들지 않았다"는 이유만으로 라이브러리를 채택하지 않는 것은 옳지 않습니다. 라이브러리의 핵심 원칙이 앱 구축에 대한 여러분의 우선순위와 일치한다면, 라이브러리 채택은 합리적인 선택일 수 있습니다. 인터넷에 산재된 블로그 포스트들의 "팁과 트릭"들을 조합하는 것보다는, 일관된 유지보수 이력과 강력한 커뮤니티를 가진 잘 정의된 도구들을 사용하는 것이 더 낫습니다.

블로그 포스트들은 주로 특정 순간에 흥미롭고 도움이 되었던 것들의 관점에서 작성되지만, 시간이 지나도 유효하지 않을 수 있습니다. 실제 앱 개발에서 마주치는 많은 엣지 케이스들에 대해 검증된 블로그 포스트는 얼마나 될까요? 작성자들이 4년이 지난 후에도 여전히 사용하는 블로그 포스트 기법은 얼마나 될까요? 실제 적용 사례와 시간에 따른 진화 과정을 설명하는 후속 회고를 가진 블로그 포스트는 얼마나 될까요?

따라서 우리는 서드파티 라이브러리 채택이 블로그 포스트의 아이디어를 채택하는 것보다 크게 위험하다고 생각하지 않습니다. 하지만 여러분의 애플리케이션에 대한 우선순위를 파악하는 것은 여러분과 여러분의 팀의 몫입니다.

### TCA는 SwiftUI의 방향성에 반하나요?

우리는 실제로 TCA가 SwiftUI를 잘 보완한다고 생각합니다! TCA의 설계는 SwiftUI에서 많은 영감을 받았으며, 따라서 많은 유사점을 발견할 수 있습니다:

- TCA 기능들은 SwiftUI처럼 최소한의 상태 변화를 암시적으로 관찰할 수 있습니다. Swift의 @Observable과 유사한 @ObservableState 매크로를 사용합니다. 우리는 Swift의 관찰 도구들을 iOS 16 이전 버전에서도 사용할 수 있도록 백포트했습니다.
- SwiftUI 기능들을 조합하는 것처럼 TCA 기능들을 조합할 수 있으며, body 프로퍼티를 구현하고 result builder 구문을 사용합니다.
- 의존성은 SwiftUI의 @Environment 프로퍼티 래퍼와 비슷하게 작동하는 @Dependency 프로퍼티 래퍼를 사용하여 선언되지만, 뷰 외부에서도 작동합니다.
- 라이브러리의 상태 공유 도구들은 SwiftUI의 @Binding 도구와 매우 유사하게 작동하지만, 뷰 외부에서도 작동하며 100% 테스트 가능합니다.

또한 우리는 종종 TCA가 SwiftUI의 슈퍼파워를 더 완벽하게 활용할 수 있게 해준다고 생각합니다:

- TCA 앱은 값 타입에서 Swift의 관찰 도구를 사용할 수 있습니다. 반면 기본 SwiftUI는 참조 타입으로만 제한됩니다. 관찰 제안의 작성자는 원래 @Observable이 값 타입에서도 작동하도록 의도했지만 Swift의 제한으로 인해 포기해야 했습니다. 하지만 우리는 Store 타입 덕분에 이러한 제한을 극복할 수 있습니다.
- TCA의 내비게이션은 sheet(item:), popover(item:), 심지어 NavigationStack과 같은 기본 SwiftUI의 모든 도구를 사용합니다. 하지만 우리는 또한 enum과 optional과 같은 더 간결한 도메인에서 내비게이션을 구동하기 위한 도구도 제공합니다.
- TCA는 추가 작업 없이도 기능의 로직과 동작을 대체 버전으로 "핫 스왑"할 수 있게 합니다. 예를 들어 SwiftUI의 redacted API를 사용하여 UI의 "플레이스홀더" 버전을 표시할 때, 상호작용 시 아무 동작도 하지 않는 "비활성" 버전으로 기능의 로직을 교체할 수 있습니다.
- TCA 기능은 의존성이 처음부터 제어되기 때문에 Xcode 프리뷰에서 보기가 더 쉽습니다. 프리뷰에서 작동하지 않는 의존성들(예: 위치 관리자)도 있고, 프리뷰에서 사용하기 위험한 것들(예: 분석 클라이언트)도 있지만, 의존성을 적절히 제어하면 이에 대해 걱정할 필요가 없습니다.
- TCA 기능은 UI 테스트를 실행할 필요 없이 의존성이 어떻게 실행되고 시스템에 데이터를 다시 공급하는지를 포함하여 완전히 테스트할 수 있습니다.

그리고 SwiftUI와 그 패턴에 더 익숙할수록 Composable Architecture를 더 잘 활용할 수 있습니다. 우리는 TCA를 사용하기 위해 SwiftUI를 포기해야 한다고 말한 적이 없으며, 실제로는 그 반대가 사실이라고 생각합니다!

### TCA는 단순히 Redux의 포팅이 아닌가요? 라이브러리가 필요한가요?

TCA가 Redux와 일부 아이디어와 용어를 공유하긴 하지만, 두 라이브러리는 매우 다릅니다. 우선, Redux는 JavaScript 라이브러리이며, 앱 아키텍처의 많은 문제에 대한 의견이 있는 포괄적인 솔루션이 되려고 한 적이 없습니다. Redux는 특정 문제에 초점을 맞추고 그것에 집중했습니다.

TCA는 앱 아키텍처에서 흔히 마주치는 많은 일반적인 문제들을 위한 도구들을 포함하도록 초점을 넓혔습니다:

- 간결한 도메인 모델링을 위한 도구들
- 참조 타입 대신 값 타입을 완전히 수용할 수 있게 함
- Apple 플랫폼(SwiftUI, UIKit, AppKit 등)과의 통합을 위한 전체 도구 세트 제공(내비게이션 포함)
- 앱 전체에 걸쳐 의존성을 제어하고 전파하기 위한 강력한 의존성 관리 시스템
- 사용자 액션에 대한 기능의 동작을 철저히 테스트할 수 있게 하는 테스팅 도구(부수 효과가 어떻게 실행되고 시스템에 데이터를 다시 공급하는지 포함)
- 그 외 더 많은 기능들!

Redux는 위의 문제들에 대한 도구를 자체적으로 제공하지 않습니다.

물론 TCA를 직접 사용하는 대신 TCA에서 영감을 받은 자체 라이브러리를 구축할 수도 있으며, 실제로 많은 대기업들이 그렇게 하고 있습니다. 하지만 수년간 TCA가 만들어온 지속적인 개발과 개선을 놓치게 될 수 있다는 점도 고려할 가치가 있습니다. 우리는 iOS의 각 주요 릴리스마다 TCA를 최신 상태로 유지해왔으며, 여기에는 동시성 도구, NavigationStack, Swift 5.9의 관찰 도구(iOS 13까지 백포트함), 상태 공유 도구 등이 포함됩니다. 또한 TCA를 사용하는 수천 명의 개발자 커뮤니티와 GitHub 토론, Slack을 놓치게 될 것입니다.

### TCA로 만든 기능들은 보일러플레이트가 많은가요?

사람들은 종종 "뷰 스토어"라고 알려진 레거시 개념과 관련하여 TCA의 보일러플레이트를 불평합니다. 이는 뷰에서 최소한의 상태를 관찰할 수 있게 해주는 객체였지만, Swift 5.9에서 Observation 프레임워크가 출시된 후 오래 전에 deprecated 되었습니다. 현대의 TCA로 만든 기능들은 뷰 스토어에 대해 걱정할 필요가 없으며, 대신 기본 SwiftUI처럼 스토어에서 직접 상태에 접근하면 뷰가 최소한의 상태를 관찰할 수 있습니다.

우리의 경험상, 표준 TCA 기능은 동등한 기본 SwiftUI 기능보다 훨씬 더 많은 코드 라인을 필요로 하지 않아야 하며, 테스트를 작성하거나 TCA가 제공하는 도구를 사용하여 기능들을 통합하는 경우에는 동등한 기본 코드보다 훨씬 적은 코드가 필요해야 합니다.

### 별도의 "액션" enum을 유지하는 것이 불필요한 작업 아닌가요?

어떤 객체에 정의된 메서드 대신 enum으로 사용자 액션을 모델링하는 것은 분명히 큰 결정이며, 일부 사람들은 이를 불편하게 생각하지만, 이는 단순히 재미로 만들어진 것이 아닙니다. 애플리케이션의 모든 액션에 대한 데이터 설명을 가짐으로써 얻는 엄청난 이점들이 있습니다:

- 전용 @Observable 모델 클래스보다 더 완벽하게 기능의 로직을 기능의 뷰에서 분리합니다. 기존 리듀서를 감싸고 원하는 방식으로 기본 리듀서의 로직을 "조정"하는 리듀서를 작성할 수 있습니다.

예를 들어, 우리의 오픈 소스 단어 게임인 isowords에서는 온보딩 기능이 게임 기능을 내부에서 실행하지만 추가 로직이 더해져 있습니다. 각 게임 액션이 단순한 enum 설명을 가지고 있기 때문에 모든 액션을 가로채고 추가 로직을 실행할 수 있습니다. 예를 들어, 사용자가 온보딩 중에 단어를 제출할 때 어떤 단어를 제출했는지와 온보딩 프로세스의 어떤 단계에 있는지를 검사하여 다음 단계로 진행해야 하는지 결정할 수 있습니다:

```swift
case .game(.submitButtonTapped):
  switch state.step {
  case
    .step5_SubmitGame where state.game.selectedWordString == "GAME",
    .step8_FindCubes where state.game.selectedWordString == "CUBES",
    .step12_CubeIsShaking where state.game.selectedWordString == "REMOVE",
    .step16_FindAnyWord where dictionary.contains(state.game.selectedWordString, .en):
    state.step.next()
```

이는 enum 액션 설명 덕분에 구현하기 쉬웠던 꽤 복잡한 로직입니다. 게다가 이 모든 것이 100% 단위 테스트 가능했습니다.

기능의 모든 액션에 대한 데이터 타입을 가지면 강력한 디버깅 도구를 작성할 수 있습니다. 예를 들어, _printChanges() 리듀서 연산자는 시스템에 들어오는 모든 액션에 대한 통찰을 제공하며, 액션이 처리될 때 상태가 어떻게 변경되었는지 보여주는 깔끔하게 포맷된 메시지를 출력합니다:

```
received action:
  AppFeature.Action.syncUpsList(.addSyncUpButtonTapped)
  AppFeature.State(
    _path: [:],
    _syncUpsList: SyncUpsList.State(
-     _destination: nil,
+     _destination: .add(
+       SyncUpForm.State(
+         …
+       )
+     ),
      _syncUps: #1 […]
    )
  )
```

또한 signpost라는 도구를 만들어 앱의 잠재적인 성능 문제를 찾기 위해 기능의 모든 액션을 자동으로 signpost로 계측할 수 있습니다. 서드파티들은 앱의 모든 액션에 대한 데이터 표현이 있다는 사실 덕분에 기능을 추적하고 계측하기 위한 자체 도구를 구축했습니다.

기능의 모든 액션에 대한 데이터 타입을 가지면 기능의 모든 측면에 대해 철저한 테스트를 작성할 수도 있습니다. TestStore라는 것을 사용하여 액션을 보내고 각 단계에서 상태가 어떻게 변하는지 확인함으로써 사용자 흐름을 에뮬레이트할 수 있습니다. 또한 받은 액션을 확인함으로써 효과가 어떻게 데이터를 시스템에 다시 공급하는지도 확인해야 합니다:

```swift
store.send(.refreshButtonTapped) {
  $0.isLoading = true
}
store.receive(\.userResponse) {
  $0.currentUser = User(id: 42, name: "Blob")
  $0.isLoading = false
}
```

이 역시 기능의 모든 액션에 대한 데이터 타입이 있기에 가능합니다.

### 앱의 모든 상태가 하나의 거대한 타입에 보관되어 TCA 기능이 비효율적인가요?

이는 자주 제기되지만, 실제로 기능들이 어떻게 모델링되는지를 오해한 것입니다. TCA로 만든 앱이 앱의 모든 가능한 화면의 상태를 문자 그대로 한꺼번에 모두 보유하고 있는 것은 아닙니다. 실제로 대부분의 앱 기능은 한 번에 모두 표시되지 않고 점진적으로 표시됩니다. 기능들은 시트, 드릴다운 및 기타 형태의 내비게이션으로 표시되며, 이러한 내비게이션 형태들은 optional 상태로 제한됩니다. 이는 기능이 표시되지 않으면 해당 상태가 nil이며, 따라서 앱 상태에 표현되지 않는다는 것을 의미합니다.

### 그것이 뷰의 과도한 렌더링을 유발하나요?

실제로 뷰는 @Observable 매크로를 사용하는 기본 SwiftUI에서처럼 뷰에서 접근하는 상태를 기반으로 최소한의 횟수로 재계산됩니다. 하지만 우리는 관찰 프레임워크를 iOS 13까지 백포트했기 때문에 iOS 16 지원을 중단할 때까지 기다릴 필요 없이 오늘날 이 도구들을 사용할 수 있습니다.

### 큰 값 타입은 변경하기에 비용이 많이 드나요?

Swift에서 제자리 변경(in-place mutation)의 경우 그렇지 않은 것 같습니다. 우리의 테스트에 따르면 inout을 통한 변경은 꽤 효율적이며, Swift의 새로운 borrowing과 consuming 도구들이 이를 더욱 효율적으로 만들 가능성이 있습니다.

### 큰 값 타입이 스택 오버플로우를 일으킬 수 있나요?

큰 값 타입이 스택을 오버플로우할 수 있다는 것은 사실이지만, 실제로 라이브러리의 내비게이션 도구들을 사용하면 이는 발생하지 않습니다. 내비게이션 도구들은 앱 상태의 각 표시 노드에 힙 할당된 copy-on-write 래퍼를 삽입합니다. 따라서 기능 A가 기능 B를 표시할 수 있다면, 기능 A의 상태가 문자 그대로 기능 B의 상태를 포함하는 것은 아닙니다.

### TCA 기능들은 과도한 "핑퐁"이 있지 않나요?

여러 효과를 수행하고 싶을 때 여러 액션을 보내야 하는 액션 "핑퐁"에 대한 불만이 있었습니다:

```swift
case .refreshButtonTapped:
  return .run { send in 
    await send(.userResponse(apiClient.fetchCurrentUser()))
  }
case let .userResponse(response):
  return .run { send in 
    await send(.moviesResponse(apiClient.fetchMovies(userID: response.id)))
  }
case let .moviesResponse(response):
  // response로 무언가를 함
```

하지만 이는 상태 변경과 비동기 작업을 섞어야 할 때만 필요합니다. 중간에 상태 변경 없이 여러 비동기 작업만 실행해야 한다면, 모든 작업을 하나의 효과에 넣을 수 있습니다:

```swift
case .refreshButtonTapped:
  return .run { send in 
    let userResponse = await apiClient.fetchCurrentUser()    
    let moviesResponse = await apiClient.fetchMovies(userID: userResponse.id)
    await send(.moviesResponse(moviesResponse))
  }
```

그리고 이러한 비동기 작업들 사이에 상태 변이가 정말 필요한 경우에는 약간의 핑퐁이 발생할 수 있습니다. 하지만 위에서 언급했듯이, 액션을 데이터로 표현함으로써 뷰로부터 로직의 극단적인 분리, 강력한 디버깅 도구, 기능의 모든 측면을 테스트할 수 있는 능력 등 큰 이점이 있습니다. TCA를 사용하지 않는 앱에서 이러한 기능들을 구현하려고 한다면, 결국 같은 핑퐁 현상에 직면하게 될 것입니다.

### 기능들이 값 타입으로 구축되면 값 타입이 복사되기 때문에 상태를 공유할 수 없지 않나요?
이는 예전에는 사실이었지만, 라이브러리 버전 1.10에서 여러 기능 간에 상태를 쉽게 공유할 수 있고, 사용자 기본 설정이나 파일 시스템과 같은 외부 시스템에 상태를 유지할 수 있는 새로운 상태 공유 도구들을 출시했습니다.
더욱이, 앱에 공유 상태를 도입할 때의 위험 중 하나는 도메인에 참조 의미론을 도입하여 이해하기 어렵게 만든다는 것입니다. 하지만 우리는 공유 상태가 100% 테스트 가능하고, 심지어 철저하게 테스트 가능하도록 추가 작업을 했습니다. 이는 기능에서 공유 상태가 어떻게 변경되는지 추적하기가 훨씬 쉽게 만듭니다.

### TCA를 배우거나 사용하기 위해 Point-Free 구독이 필요한가요?
우리 웹사이트에서 구독자 전용 자료를 많이 공개하지만, 완전히 무료로 제공되는 자료도 엄청나게 많습니다. TCA 문서에는 도메인 모델링, 내비게이션, 의존성, 테스팅 등을 보여주는 복잡한 앱을 처음부터 구축하는 대규모 튜토리얼을 포함하여 수많은 문서와 튜토리얼이 포함되어 있습니다.

### TCA를 사용하기 위해 "함수형 프로그래밍"에 익숙해야 하나요?
TCA는 자신을 "함수형 프로그래밍" 라이브러리라고 설명한 적이 없습니다. 결국 Swift는 함수형 언어가 아니므로, "순수" 함수와 같은 함수형 패턴을 컴파일 시점에 강제할 방법이 없습니다. 따라서 "함수형 프로그래밍"에 대한 친숙도는 필요하지 않습니다.

하지만 함수형 프로그래밍 언어의 특정 개념들은 우리에게 매우 중요하며, 이러한 개념들을 사용하여 라이브러리의 여러 측면을 안내했습니다. 예를 들어, 라이브러리의 핵심 원칙은 "원거리 작용"을 허용하는 참조 타입 대신, 이해하기 쉽고 동작이 없는 값 타입을 사용하여 도메인을 최대한 구축하는 것입니다. 라이브러리는 또한 순수 로직 변환에서 부수 효과를 분리하는 것을 중요하게 여깁니다. 이를 통해 부수 효과가 어떻게 실행되고 시스템에 데이터를 다시 공급하는지를 포함하여 훌륭한 테스트 가능성을 제공합니다.

하지만 이러한 개념들에 대한 사전 경험이 필요하지는 않습니다. 이러한 아이디어들은 라이브러리와 문서에 녹아있으므로, 우리의 자료와 데모 앱을 따라하면서 자연스럽게 경험을 쌓을 수 있습니다.
